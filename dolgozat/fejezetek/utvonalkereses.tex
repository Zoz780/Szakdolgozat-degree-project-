\Chapter{Útvonalkeresés}
\label{Chap:utvonalkereses}

A fejezet az útvonalkeresésnél alkalmazott módszereket mutatja be.

\section{A waypoint-ok fogalma és jellemzői}

Ez egy térben meghatározott egyszerű pont, amely nem látható a játkos számára. A mesterséges intelligencia ezeket használja fel az ellenfelek mozgatásához. Azért van rájuk szükség, mert a pályán vannak falak, különböző játékelemek, amiken nem lehet átmenni, és ezekkel a pontokkal egyértelműen meg lehet határozni, hogy melyek azok a helyek, amelyek bejárhatók.

A waypoint-okhoz rendelhetünk különféle többletinformációkat. Ilyenek lehet például, hogy az adott pontban a gépi játékosnak megállnia, guggolnia.

\section{A waypoint-hoz tartozó adatok}

A waypoint-ok pozícióját két dimenziós Descartes koordináta rendszerben $(x, y)$ koordinátákkal adhatjuk meg. Annak ellenére, hogy térben vagyunk, nincs szükség $z$ koordinátára, mert a talaj magassága külön kezelendő, mivel az hatással lesz az ellenfelek viselkedésére. Ennek köszönhetően mindig az adott pálya talajmagasságához tud igazodni, nem szükséges azt külön megadni.

Fontos, hogy a waypoint-nak legyen egy típusa, amely meghatározza, hogy az adott pont milyen szerepet játszik. Ennek segítségével ki lehet számolni, hogy a játékban szereplő karakterek hova mehetnek.

\section{Útvonalkeresés waypoint-ok alapján}

% NOTE: De pontosan hogyan használjuk fel a waypointokat a mesterséges intelligenciához?

Tegyük fel, a gép létrehoz egy ellenfelet egy véletlenszerű pozícióba. (Ezt a szakzsargonban \textit{spawn}-olásnak hívják.) Az ellenfeleknek az a fő feladatuk, hogy a lehető legrövidebb útvonalon eljussanak a játékoshoz, és megtámadják. 

Az útvonalkeresés folyamata a következő fő lépésekből épül fel.
\begin{itemize}
\item A waypoint-ok közül megkeressük az adott karakterhez legközelebbit. Először ezt a pontot kell megközelíteni.
\item A pont adott, kis sugarú környezetét elérve A*-algoritmus segítségével meghatározzuk
\end{itemize}

% TODO: Készíteni egy demo-t az A*-algoritmushoz, és megnézni, hogy a legközelebbi pontok keresése pontosan hogy nézne ki, és egyáltalán kell-e hozzá külön heurisztika.

% TODO: A legközelebbi pont megkereséséhez tartozó algoritmushoz pszeudókódos leírás.

\section{Az A*-algoritmus}

% TODO: Keresni A*-algoritmusos irodalmat/hivatkozást.

Ezt az algoritmust a legrövidebb útvonal számításra gyakran használják, mert ez az egyik leghatékonyabb. Bemeneti paraméterei a start pont X, Y, és a célpont X, Y koordinátái. 

A keresést egy gráfon tudjuk végrehajtani. A gráf egy lehetséges realizációja a rács, amelyben a gráf pontjai négyzetrácsnak megfelelően helyezkednek el.

% TODO: Leírni, hogy ez a rácsos megadás miért előnyös.

Listát kell vezetni azon pontokról amiket még nem jártunk be, illetve azokról is, amelyeket bejártunk. Kell lennie egy, vagy több feltételnek, hogy az adott pontból merre haladhatunk tovább, ilyen például az, hogy csak vízszintesen és függőlegeseb haladhatunk a ponthálón, vagy átlósan is. Az a pont, amin éppen tartózkodunk az az ősnode (base node), amelyekre léphetünk, azok pedig a gyerek node-ok (child node).

X és Y pozíció, ezen felül kell lennie egy változónak, amiben az adott pontig bejárt távolság található. Illetve le kell tárolni egy prioritás változót is, amiben az eddig megtett út, és a még hátralevő út távolságainak összege található.
Fontos ugyanis az algoritmus működése szempontjából az eddig megtett, és a hátralévő út, ugyanis ezekből az adatokból számolja ki egy adott pont prioritását (kezdőponttól való táv + célponttól való táv), és így dönti el milyen pontokat részesítsen előnyben. A prioritás minél kisebb érték, annál jobb, szóval arra kell elindulni. Ha egy idő után falba ütközik, elkezdi vizsgálni mindig a lehető legkisebb prioritással rendelkező, még szabad pontokat, egészen addig, még utat nem talál valahol magának.

% TODO: Az A*-algoritmus pszeudókódját részletesen megadni. (Az előző bekezdéseket annak megfelelően kellene átírni majd.)

% NOTE: Milyen adatok tartoznak egy node-hoz?

\section{A pontos megvalósítás}

A program a játéktér alapját képző domborzatot, egy képből olvassa be. Ez a magasságmező, ahol egy adott pont magasságát a világossága határozza meg, minél világosabb, annál magasabb pontot jelent a domborzaton, így 256 féle magasság lehetséges, ami az aktuális változathoz megfelelő felbontásnak bizonyult. 

A játéktér jelentős része (körülbelül 95\%) bejárható. A magasságmezőhöz tartozó kép felbontása $384 \times 384$ pixel.

% TODO: Miért pont ennyi a felbontás? Megvizsgálni, hogy milyen hatással van a felbontásnak a többi részre. Megmutatni, hogy ez miért lehet ideális. (Ehhez esetleg lehet csinálni számítási idős görbét, vagy problémás eseteket részletezni.)

% TODO: Készíteni egy ábrát a küszöbölésről (a maasságmező metszevel például).

Első lépésként, létre kell hozni a waypoint hálót, amiken a mesterséges intelligencia végig fog menni, elkerülvén hogy átmenjen a tereptárgyakon, falakon. Ezek a pontok 4 pixelenként, függetlenül az adott pixel színétől meghatározásra kerülnek, viszont a típusa az adott pixel színének megfelelően lesz beállítva. Ha például egy pont színéből 50-nél nagyobb érték jön ki, akkor a pont típusa zártra állítódik, így ebbe az irányba nem lesz lehetséges a továbbhaladás. A képen „.”-al a bejárható terület, „X”-el a falak, „S”-el az indulópont, „F”-el a célpont, „R”-el a legrövidebb útvonal van jelölve.

A képen még csak statikusan vannak megadva a falak, de mint ahogy fentebb olvasható, a játékon belül a beolvasott magasságmező színe határozza ezt meg. Erre azért van szükség, mert így lehet megoldani azt, hogy a mesterséges intelligencia alkalmazkodjon a környezetéhez. Ha a pályától függetlenül, statikusan lenne az összes waypoint típusa meghatározva, akkor ha a játékos más pályát rajzol, a pontok típusai nem illeszkednének a layoutra. Ezt a módszert alkalmazva, meg lehet adni, hogy egy bizonyos magasságnál csak másszon, vagy ugorjon, stb. Ez egy fontos tulajdonsága a játéknak, mert azt úgy terveztem, hogy ha a felhasználó akár paint-ben rajzol egy pályát, akkor a teret azonnal kialakítsa, beállítsa hogy a falakon a játékos ne tudjon átmenni, a meredek lejtőkről visszacsússzon, illetve a mesterséges intelligencia is alkalmazkodjon.

% TODO: Megmutatni a naiv, küszöbölős megoldást a falak meghatározására.

% TODO: Megnézni, hogy gradiens alapján hogy lehet meghatározni. Ha túl nagy a gradiens akkor nem lehet az adott részen áthaladni.

A pontok típusának a pálya alapján legenerálása után, az A*-algoritmus segítségével meghatározza a program a legrövidebb útvonalat a cél waypointig, természetesen a pontok típusait figyelembe véve. Ezt másodpercenként legalább 15x újra kell számolni, ugyanis a játékos mozog, és a cél waypoint mindig a játékoshoz legközelebb eső pont, ami ezzel együtt változik.

% TODO: Waypointok generálása: Delaunay triangulation
